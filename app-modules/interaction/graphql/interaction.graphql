union Interactable = Student | Prospect

type Interaction
    @model(class: "AdvisingApp\\Interaction\\Models\\Interaction") {
    "Unique primary key."
    id: ID!

    "The subject of the interaction."
    subject: String!

    "The description of the interaction."
    description: String!

    "The User related to the interaction."
    user: User @belongsTo

    # TODO: A ServiceRequest
    "The Interactable related to the interaction."
    interactable: Interactable @morphTo

    "The type of interaction."
    type: InteractionType @belongsTo

    "The relation of the interaction."
    relation: InteractionRelation @belongsTo

    "The campaign of the interaction."
    campaign: InteractionCampaign @belongsTo

    "The driver of the interaction."
    driver: InteractionDriver @belongsTo

    "The status of the interaction."
    status: InteractionStatus @belongsTo

    "The outcome of the interaction."
    outcome: InteractionOutcome @belongsTo

    "The division of the interaction."
    division: Division @belongsTo

    "The start datetime of the interaction."
    start_datetime: DateTime!

    "The end datetime of the interaction."
    end_datetime: DateTime

    "The created datetime of the interaction."
    created_at: DateTime

    "The updated datetime of the interaction."
    updated_at: DateTime
}

# TODO: Query and Mutate

enum QueryInteractionsWhereColumn {
    subject
    description
    start_datetime
    end_datetime
    created_at
    updated_at
}

enum QueryInteractionsHasUserColumn {
    id
    email
}

enum QueryInteractionsHasTypeColumn {
    id
    name
}

enum QueryInteractionsHasInteractableEnum {
    full_name
}

enum QueryInteractionsHasRelationColumn {
    id
    name
}

enum QueryInteractionsHasCampaignColumn {
    id
    name
}

enum QueryInteractionsHasDriverColumn {
    id
    name
}

enum QueryInteractionsHasStatusColumn {
    id
    name
    color
}

enum QueryInteractionsHasOutcomeColumn {
    id
    name
}

enum QueryDivisionsWhereColumn{
    id
}

extend type Query {
    "Find a single interaction by an identifying attribute."
    interaction(
        "The value of the attribute to match."
        id: ID! @whereKey
    ): Interaction @find @canResolved(ability: "view")

    "List multiple interactions."
    interactions(
        "Filter by the interactions attributes."
        where: _ @whereConditions(columnsEnum: QueryInteractionsWhereColumn)

        "Filter by the user relationship."
        hasUser: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasUserColumn)

        # TODO: Look into improving Polymorphic whereHas
        hasInteractable: _
            @whereHasConditions(
                columnsEnum: QueryInteractionsHasInteractableEnum
            )

        "Filter by the type relationship."
        hasType: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasTypeColumn)

        "Filter by the relation relationship."
        hasRelation: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasRelationColumn)

        "Filter by the campaign relationship."
        hasCampaign: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasCampaignColumn)

        "Filter by the driver relationship."
        hasDriver: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasDriverColumn)

        "Filter by the status relationship."
        hasStatus: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasStatusColumn)

        "Filter by the outcome relationship."
        hasOutcome: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasOutcomeColumn)

        "Filter by the division relationship."
        hasDivision: _
            @whereHasConditions(columnsEnum: QueryDivisionsWhereColumn)
    ): [Interaction!]! @paginate @canModel(ability: "viewAny")
}

#import ./interaction-campaign.graphql
#import ./interaction-driver.graphql
#import ./interaction-outcome.graphql
#import ./interaction-relation.graphql
#import ./interaction-status.graphql
#import ./interaction-type.graphql
