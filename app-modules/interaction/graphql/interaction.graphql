union Interactable = Student | Prospect

type Interaction
    @model(class: "AdvisingApp\\Interaction\\Models\\Interaction") {
    "Unique primary key."
    id: ID!

    "The subject of the interaction."
    subject: String!

    "The description of the interaction."
    description: String!

    "The User related to the interaction."
    user: User @belongsTo

    "The Interactable related to the interaction."
    interactable: Interactable @morphTo

    "The type of interaction."
    type: InteractionType @belongsTo

    "The relation of the interaction."
    relation: InteractionRelation @belongsTo

    "The campaign of the interaction."
    campaign: InteractionCampaign @belongsTo

    "The driver of the interaction."
    driver: InteractionDriver @belongsTo

    "The status of the interaction."
    status: InteractionStatus @belongsTo

    "The outcome of the interaction."
    outcome: InteractionOutcome @belongsTo

    "The division of the interaction."
    division: Division @belongsTo

    "The start datetime of the interaction."
    start_datetime: DateTime!

    "The end datetime of the interaction."
    end_datetime: DateTime

    "The created datetime of the interaction."
    created_at: DateTime

    "The updated datetime of the interaction."
    updated_at: DateTime
}

enum QueryInteractionsWhereColumn {
    subject
    description
    start_datetime
    end_datetime
    created_at
    updated_at
}

enum QueryInteractionsHasUserColumn {
    id
    email
}

enum QueryInteractionsHasTypeColumn {
    id
    name
}

enum QueryInteractionsHasInteractableEnum {
    full_name
}

enum QueryInteractionsHasRelationColumn {
    id
    name
}

enum QueryInteractionsHasCampaignColumn {
    id
    name
}

enum QueryInteractionsHasDriverColumn {
    id
    name
}

enum QueryInteractionsHasStatusColumn {
    id
    name
    color
}

enum QueryInteractionsHasOutcomeColumn {
    id
    name
}

enum QueryDivisionsWhereColumn {
    id
}

extend type Query {
    "Find a single interaction by an identifying attribute."
    interaction(
        "The value of the attribute to match."
        id: ID! @whereKey
    ): Interaction @find @canResolved(ability: "view")

    "List multiple interactions."
    interactions(
        "Filter by the interactions attributes."
        where: _ @whereConditions(columnsEnum: QueryInteractionsWhereColumn)

        "Filter by the user relationship."
        hasUser: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasUserColumn)

        # TODO: Look into improving Polymorphic whereHas
        hasInteractable: _
            @whereHasConditions(
                columnsEnum: QueryInteractionsHasInteractableEnum
            )

        "Filter by the type relationship."
        hasType: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasTypeColumn)

        "Filter by the relation relationship."
        hasRelation: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasRelationColumn)

        "Filter by the campaign relationship."
        hasCampaign: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasCampaignColumn)

        "Filter by the driver relationship."
        hasDriver: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasDriverColumn)

        "Filter by the status relationship."
        hasStatus: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasStatusColumn)

        "Filter by the outcome relationship."
        hasOutcome: _
            @whereHasConditions(columnsEnum: QueryInteractionsHasOutcomeColumn)

        "Filter by the division relationship."
        hasDivision: _
            @whereHasConditions(columnsEnum: QueryDivisionsWhereColumn)
    ): [Interaction!]! @paginate @canModel(ability: "viewAny")
}

input UpdateInteractionInput {
    "The subject of the interaction."
    subject: String @rules(apply: ["string", "max:255"])

    "The description of the interaction."
    description: String @rules(apply: ["string"])

    "The User related to the interaction."
    user_id: ID @rules(apply: ["exists:users,id"])

    "The Interactable related to the interaction."
    interactable_id: ID
        @rules(
            apply: [
                "AdvisingApp\\Interaction\\Rules\\InteractableIdExistsRules"
                "required_with:interactable_type"
            ]
        )

    "The type of Interactable related to the interaction."
    interactable_type: String
        @rules(
            apply: [
                "in:student,prospect,service_request"
                "required_with:interactable_id"
            ]
        )

    "The type of interaction."
    interaction_type_id: ID @rules(apply: ["exists:interaction_types,id"])

    "The relation of the interaction."
    interaction_relation_id: ID
        @rules(apply: ["exists:interaction_relations,id"])

    "The campaign of the interaction."
    interaction_campaign_id: ID
        @rules(apply: ["exists:interaction_campaigns,id"])

    "The driver of the interaction."
    interaction_driver_id: ID @rules(apply: ["exists:interaction_drivers,id"])

    "The status of the interaction."
    interaction_status_id: ID @rules(apply: ["exists:interaction_statuses,id"])

    "The outcome of the interaction."
    interaction_outcome_id: ID @rules(apply: ["exists:interaction_outcomes,id"])

    "The division of the interaction."
    division_id: ID @rules(apply: ["exists:divisions,id"])

    "The start datetime of the interaction."
    start_datetime: DateTime @rules(apply: ["date_format:Y-m-d H:i:s"])

    "The end datetime of the interaction."
    end_datetime: DateTime
        @rules(apply: ["nullable", "date_format:Y-m-d H:i:s"])
}

extend type Mutation {
    "Create a interaction."
    createInteraction(
        "The subject of the interaction."
        subject: String! @rules(apply: ["required", "string", "max:255"])

        "The description of the interaction."
        description: String! @rules(apply: ["required", "string"])

        "The User related to the interaction."
        user_id: ID! @rules(apply: ["required", "exists:users,id"])

        "The Interactable related to the interaction."
        interactable_id: ID!
            @rules(
                apply: [
                    "required"
                    "AdvisingApp\\Interaction\\Rules\\InteractableIdExistsRules"
                ]
            )

        "The type of Interactable related to the interaction."
        interactable_type: String!
            @rules(apply: ["required", "in:student,prospect,service_request"])

        "The type of interaction."
        interaction_type_id: ID!
            @rules(apply: ["required", "exists:interaction_types,id"])

        "The relation of the interaction."
        interaction_relation_id: ID!
            @rules(apply: ["required", "exists:interaction_relations,id"])

        "The campaign of the interaction."
        interaction_campaign_id: ID!
            @rules(apply: ["required", "exists:interaction_campaigns,id"])

        "The driver of the interaction."
        interaction_driver_id: ID!
            @rules(apply: ["required", "exists:interaction_drivers,id"])

        "The status of the interaction."
        interaction_status_id: ID!
            @rules(apply: ["required", "exists:interaction_statuses,id"])

        "The outcome of the interaction."
        interaction_outcome_id: ID!
            @rules(apply: ["required", "exists:interaction_outcomes,id"])

        "The division of the interaction."
        division_id: ID! @rules(apply: ["required", "exists:divisions,id"])

        "The start datetime of the interaction."
        start_datetime: DateTime!
            @rules(apply: ["required", "date_format:Y-m-d H:i:s"])

        "The end datetime of the interaction."
        end_datetime: DateTime
            @rules(apply: ["nullable", "date_format:Y-m-d H:i:s"])
    ): Interaction! @create @canModel(ability: "create")

    "Update a interaction."
    updateInteraction(
        "The identifier of the interaction you would like to update."
        id: ID! @whereKey

        input: UpdateInteractionInput! @spread
    ): Interaction! @canFind(ability: "update", find: "id") @update

    "Delete a interaction."
    deleteInteraction(
        "The identifier of the interaction you would like to delete."
        id: ID! @whereKey
    ): Interaction @canFind(ability: "delete", find: "id") @delete
}

#import ./interaction-campaign.graphql
#import ./interaction-driver.graphql
#import ./interaction-outcome.graphql
#import ./interaction-relation.graphql
#import ./interaction-status.graphql
#import ./interaction-type.graphql
