type UserSubscription
    @model(class: "AdvisingApp\\Notifications\\Models\\Subscription") {
    "Unique primary key."
    id: UUID!
    "The User related to this subscription."
    user: User! @belongsTo
    "The Subscribable the User is subscribed to."
    subscribable: Educatable! @morphTo
    "The created date of the subscription."
    created_at: DateTime
    "The updated date of the subscription."
    updated_at: DateTime
}

input UserSubscriptionSubscribablesQuery {
    student: StudentQuery
    prospect: ProspectQuery
}

input SubscriptionsQuery {
    id: UUID
    user: UserQuery
    subscribable: UserSubscriptionSubscribablesQuery @morphToRelation
    subscribable_id: EducatableId
    subscribable_type: EducatableType
    created_at: DateTime
    updated_at: DateTime
}

extend type Query {
    "Find a single subscription by an identifying attribute."
    userSubscription(
        "The value of the attribute to match."
        id: UUID!
            @whereKey
            @rules(apply: ["required", "uuid", "exists:subscriptions"])
    ): UserSubscription @find @canResolved(ability: "view")

    "List multiple subscriptions."
    userSubscriptions(
        where: SubscriptionsQuery @searchBy
    ): [UserSubscription!]! @paginate @canModel(ability: "viewAny")
}

input CreateUserSubscriptionInput {
    "The user to subscribe."
    user_id: UUID!
        @rules(
            apply: [
                "required"
                "exists:users,id"
                "AdvisingApp\\Notifications\\Rules\\UniqueSubscriptionRule"
            ]
        )

    "The subscribable to subscribe to."
    subscribable_id: EducatableId!
        @rules(
            apply: [
                "required"
                "AdvisingApp\\Notifications\\Rules\\SubscribableIdExistsRule"
            ]
        )

    "The type of subscribable to subscribe to."
    subscribable_type: EducatableType!
        @rules(apply: ["required", "in:student,prospect"])
}

extend type Mutation {
    "Create a new subscription."
    createUserSubscription(
        input: CreateUserSubscriptionInput! @spread
    ): UserSubscription! @create @canModel(ability: "create")

    "Delete an existing subscription."
    deleteUserSubscription(
        "The primary key of the subscription."
        id: UUID!
            @whereKey
            @rules(apply: ["required", "uuid", "exists:subscriptions"])
    ): UserSubscription @delete @canFind(ability: "delete", find: "id")
}
